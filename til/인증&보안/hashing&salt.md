# Hashing
> 어떠한 문자열에 '임의의 연산'(해시 함수)을 적용하여 다른 문자열로 변환하는 것
```js
예를들어 비밀번호를 1234로 설정하였다고 하면 이 비밀번호는 client에서 서버로 전달되고 다시 서버에서 DB로 전달될텐데 이렇게 비밀번호가 암호화되지않고 바로 노출이 되면 해커가 DB에 접근하여 쉽게 비밀번호를 알수가 있으므로 hashing이 필요하다.
```
따라서 *Hashing* 은 아래와 같이 되어야 한다.
1. 모든 값에 대해 해시 값을 계산하는데 오래걸리지 않아야 한다.
2. 최대한 해시 값을 피해야 하며, 모든 값은 고유한 해시 값을 가진다.
3. 아주 작은 단위의 변경이라도 완전히 다른 해시 값을 가져야 한다.


<br>

e.g.
|Password|SHA-1 해시|
|:--:|:--:|
|q|22EA1C649C82946AA6E479E1FFD321E4A318B1B0|
|1234|7110EDA4D09E062AA5E4A390B0A572AC0D2C0220|
|abcd|81FE8BFE87576C3ECB22426F8E57847382917ACF|
|1q2w3e|9AC20922B054316BE23842A5BCA7D69F29F69D77|

Password의 길이가 1자리든 6자리든 10자리든 SHA-1해시로 암호화를 하면 항상 40자리로 변환이 된다.


<br>

# Salt
> 암호화해야하는 값에 어떤 '별도의 값'을 추가하여 결과를 변형하는 것
1. 암호화만 해놓는다면 해시된 결과가 늘 동일 <br>
   해시된 값과 원래 값을 테이블(레인보우 테이블)로 만들어서 decoding 해버리는 경우도 생긴다.
   * 레인보우테이블 : 해시 함수를 사용하여 변환한 모든 해시 값을 저장해 놓은 표
2. 원본값에 임의로 약속된 '별도의 문자열'을 추가하여 해시를 진행한다면 기본 해시값과 전혀 다른 값이 반환되어 원본을 보호할 수 있게 하는 안전 장치
3. 기존 : (암호화 하려는 값) => (해시 값) <br>
   Salt 사용 : (암호화 하려는 값) + (Salt용 값) => (해시 값)

## Salt 사용시 주의점
1. Salt는 유저와 패스워드 별로 유일한 값을 가져야 한다.
2. 사용자 계정을 생성할 때와 비밀번호를 변경할 때 마다 새로운 임의의 Salt를 사용해서 해싱해야 한다.
3. Salt는 절대 재사용하지 말아야 한다.
4. Salt는 DB의 유저 테이블에 같이 저장되어야 한다.

<br>

e.g.
|Password|Salt|SHA-1 해시|
|:--:|:--:|:--:|
|q||22EA1C649C82946AA6E479E1FFD321E4A318B1B0|
|q|.|6E231709CBBBCED3431CA7CFB4CAE1D153658A60|

위의 기존 q에서 q.으로 점 하나만 찍어도 해시값은 전혀 다르게 나온다.