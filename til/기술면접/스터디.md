|No.|질문|답변|
|:--:|:--:|:--:|
|1|클로저 (Closure)란?|함수의 **어휘적환경조합(Lexical scoping)**이라고 할 수 있습니다. 이 말은 변수가 어디서 유효한지 범위적으로 나타내는 것으로 간단하게 임의의 함수 a가 있을 경우 이 함수 안에서 변수x의 값이 할당되어 있을 경우 이 함수 밖에서는 x의 변수에 접근할 수가 없습니다. 하지만 반대로 a함수 밖의 변수 y가 있을 경우에는 함수 a에서 y의 값에 접근할 수가 있습니다.|
|2|this에 대해서 설명해주세요.|글로벌에서 사용할 경우 window 객체들이 조회가 되며 객체의 메소드 안에서 사용할 경우에는 주인객체를 가르킵니다.|
|3|브라우저의 작동원리에 대해서 설명해 주세요.|브라우저 UI에서 유저가 어떠한 동작을 요청 하였을때 브라우저 엔진이 작동을 하여 렌더링 엔진으로 필요한 데이터 요청을 합니다. @@@@@|
|4|Promise에 대해서 설명해주세요.|Promise를 사용하는 이유는 자바스크립트가 특정 코드의 작동이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행하여 비동기적으로 작동하기 위해서 입니다. 서버에 데이터 요청을 보냈을 경우 Promise를 사용하지 않는다면 데이터를 다 받아오기도 전에 데이터를 받아온 것처럼 화면에 표시하면 오류가 발생하기 때문에 이러한 문제를 해결하기 위해 Promise를 사용합니다.|
|5|React에 대해 설명해주세요.|---|
|5-1|React가 생겨난 이유?|vue.js에서 컴포넌트의 데이터 흐름의 출처를 찾기 어렵기 때문에 단방향(상위 컴포넌트에서 하위 컴포넌트)로 데이터 흐름(flux pattern)을 가진 라이브러리를 페이스북에서 자바스크립트 기반의 라이브러리인 리액트를 개발하였습니다.|
|5-2|React의 특징은?|리액트는 Virtual DOM이라는 가상의 DOM tree를 웹메모리에 저장을 해두어 이벤트가 발생할 때마다 전후의 차이를 비교하여 바뀐 내용의 html구조로 바꿔줍니다. 따라서 효율적으로 리렌더링할 필요없이 브라우저 이용이 가능합니다.|
|5-3|JSX란?|자바스크립트 확장문법으로 리액트에서 사용됨이 권장이 되어 엘리먼트를 생성합니다.|
|5-4|React-Hooks에 대해서 설명해주세요.|Hooks의 종류는 여러가지가 있는데 그 중에서도 많이 사용하는 Hooks는 useState가 있습니다. useState는 상태값을 관리하기 위해서 사용하고 초기값을 설정할 수 있습니다. [state, setState]와 같이 첫번째 인자는 현재 상태의 값, 두번째 인자는 상태를 변경시켜주는 함수입니다.|
|6|Redux에 대해서 설명해주세요.|React는 상위컴포넌트에서 하위컴포넌트로 props로 전달되는 flux pattern입니다. 하지만 프로젝트의 규모가 커질경우 최상위 컴포넌트에서 최하위 컴포넌트로 props를 전달할 경우 props -> props -> props...가 되므로 이러한 불편함을 해결하기 위해 리덕스를 사용하여 별도로 전역에서 효율적인 상태관리를 하기위해서 사용됩니다.|
|7|HTTP 와 HTTPS 차이점|http는 서버와 클라이언트의 데이터를 주고 받기 위한통신 방식이고 여기에서 https는 통신방법에서 암호화가 추가된 방식입니다. @@@@@|
|8|React를 사용하셨는데 라이프사이클은 무엇인가요.||
|9|트렌젝션 개념 및 단계에 대한 설명||
|10|상태 관리는 어떻게 하셨나요. (빈출 질문)||
|11|서버쪽은 얼마나 알고 계신가요.||    
|12|API문서를 읽을 줄 아시나요. gitbook 등을 사용하여 API를 적는 이유?||
|13|리액트에서 view까지 가는 과정을 알고 있으신가요?||
|14|자바스크립트에서 원시타입은 몇 가지인가요? 종류가 어떤 게 있나요.||
|15|실행컨텍스트에 대해서 설명해주세요.|코드를 실행하는데 필요한 환경을 제공하는 객체라고 할 수 있습니다. 여기서 환경이란 코드 실행에 영향을 주는 조건이나 상태를 모아둔 객체가 실행컨텍스트입니다. (구체적인 설명이 추가적으로 필요해 보인다. 코드가 실행될 때에 Call Stack에 쌓인 객체가 실행됨)|
|16|호이스팅(Hoisting)에 대해서(함수)|함수 표현식은 var를 사용 할 경우 선언과 동일하게 함수 실행 시 undefined가 되고 let, const와 동일하게 실행이후에 선언이 된 함수일때는 레퍼런스 에러가 발생합니다. 함수 선언식으로 작동할 경우에는 선언과 동시에 함수가 생성되어 *환경레코드*에 저장이 되어 이상없이 작동이 됩니다.|


2번 **this**는 JS-Engine 에서..
1. 객체(변수) [call stack] var 
2. scope [chained..]
3. this [context] : global (window) <-- binding(let으로 변수를 지정할 경우 binding이 안됨)
4. 값을 할당
5. hoisting

```js
var a = 10;
const test = () => {
    console.log(this.a)
}

let obj = {
    value : 11,
    func : function () {
        console.log(this)
    }
}

let temp = obj.func
temp() // this가 global이 되므로 undefined
// 추가로 봐야할 내용 (call, apply, new)
```

[README.md로 이동](../../README.md)
